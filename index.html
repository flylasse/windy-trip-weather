<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trip Weather Forecast</title>
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#2563eb">
    <meta name="description" content="Weather forecasts for your trip waypoints">
    <link rel="manifest" href="manifest.json">
    
    <!-- Favicon -->
    <link rel="icon" type="image/png" sizes="32x32" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üå§Ô∏è</text></svg>">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .card {
            background: white;
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
        }

        .upload-section {
            border: 2px dashed #ddd;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            background: #f8f9fa;
        }

        .upload-section:hover {
            border-color: #2563eb;
            background: #f8faff;
        }

        .upload-section.dragover {
            border-color: #2563eb;
            background: #e0f2fe;
        }

        #fileInput {
            display: none;
        }

        .upload-icon {
            font-size: 3rem;
            margin-bottom: 15px;
            color: #666;
        }

        .btn {
            background: linear-gradient(45deg, #2563eb, #3b82f6);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: transform 0.2s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .spinner {
            border: 4px solid #f3f4f6;
            border-top: 4px solid #2563eb;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .waypoints {
            display: none;
        }

        .waypoint {
            background: #f8faff;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 15px;
            border-left: 5px solid #2563eb;
        }

        .waypoint-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .waypoint-name {
            font-size: 1.2rem;
            font-weight: 600;
            color: #1f2937;
        }

        .coordinates {
            font-family: 'Courier New', monospace;
            color: #6b7280;
            font-size: 0.9rem;
        }

        .weather-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .weather-item {
            background: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .weather-label {
            font-size: 0.8rem;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 5px;
        }

        .weather-value {
            font-size: 1.1rem;
            font-weight: 600;
            color: #1f2937;
        }

        .api-setup {
            background: #fef3c7;
            border: 1px solid #fbbf24;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .api-input {
            width: 100%;
            padding: 10px;
            border: 2px solid #d1d5db;
            border-radius: 8px;
            font-size: 1rem;
            margin-top: 10px;
            font-family: 'Courier New', monospace;
        }

        .api-input:focus {
            outline: none;
            border-color: #2563eb;
        }

        .error {
            background: #fee2e2;
            border: 1px solid #fca5a5;
            color: #dc2626;
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
        }

        .success {
            background: #d1fae5;
            border: 1px solid #6ee7b7;
            color: #059669;
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
        }

        @media (max-width: 640px) {
            .container {
                padding: 15px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .weather-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .api-setup div[style*="display: flex"] {
                flex-direction: column !important;
                gap: 10px !important;
            }
            
            .api-setup div[style*="grid-template-columns"] {
                grid-template-columns: 1fr !important;
                gap: 8px !important;
            }
            
            .api-setup .btn {
                font-size: 0.8rem !important;
                padding: 10px 6px !important;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üå§Ô∏è Trip Weather</h1>
            <p>Upload your GPX route and get detailed weather forecasts for each waypoint</p>
            <div style="font-size: 0.8rem; color: rgba(255,255,255,0.7); margin-top: 10px;">
                Version 1.2.07 | User-Controlled Actions & Cleaner UI
            </div>
        </div>

        <div class="card">
            <div class="api-setup">
                <h3>üîë Windy API Setup</h3>
                <p>Get your free API key from <a href="https://api.windy.com" target="_blank">api.windy.com</a></p>
                
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="password" id="apiKey" class="api-input" placeholder="Enter your Windy API key..." style="flex: 1; margin-top: 0;" />
                    <button class="btn" onclick="saveApiKey()">Save API Key</button>
                </div>
                
                <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #e5e7eb;">
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
                        <button class="btn" onclick="testApiKey()" style="background: linear-gradient(45deg, #059669, #10b981); font-size: 0.9rem; padding: 12px 8px;">
                            üß™ Sample SF Forecast
                        </button>
                        <button class="btn" onclick="loadDefaultRoute()" style="background: linear-gradient(45deg, #2563eb, #3b82f6); font-size: 0.9rem; padding: 12px 8px;">
                            üó∫Ô∏è Sample Route
                        </button>
                        <button class="btn" onclick="document.getElementById('fileInput').click()" style="background: linear-gradient(45deg, #dc2626, #ef4444); font-size: 0.9rem; padding: 12px 8px;">
                            üìÅ Upload GPX
                        </button>
                    </div>
                    <div style="font-size: 0.8rem; color: #6b7280; margin-top: 8px; text-align: center;">
                        üí° Test your API key, try the sample route, or upload your own GPX file
                    </div>
                </div>
                
                <input type="file" id="fileInput" accept=".gpx,.gpxd,.xml" style="display: none;" />
            </div>

            <div class="loading">
                <div class="spinner"></div>
                <div id="loadingText">Processing your file...</div>
                <div id="loadingProgress" style="margin-top: 10px; font-size: 0.9rem; color: #6b7280;"></div>
            </div>

            <div class="waypoints"></div>
        </div>
    </div>

    <script>
        // UI feedback functions
        function showLoading(text = 'Processing...', progress = '') {
            const loadingDiv = document.querySelector('.loading');
            const loadingText = document.getElementById('loadingText');
            const loadingProgress = document.getElementById('loadingProgress');
            
            if (loadingText) loadingText.textContent = text;
            if (loadingProgress) loadingProgress.textContent = progress;
            
            loadingDiv.style.display = 'block';
            waypointsDiv.style.display = 'none';
            
            debugLog('ui-loading', `Showing: ${text} | ${progress}`);
        }

        function hideLoading() {
            const loadingDiv = document.querySelector('.loading');
            loadingDiv.style.display = 'none';
            debugLog('ui-loading', 'Loading hidden');
        }

        function updateProgress(text, progress = '') {
            const loadingText = document.getElementById('loadingText');
            const loadingProgress = document.getElementById('loadingProgress');
            
            if (loadingText) loadingText.textContent = text;
            if (loadingProgress) loadingProgress.textContent = progress;
            
            debugLog('ui-progress', `Updated: ${text} | ${progress}`);
        }

        // Debug logging utility
        function debugLog(step, data, level = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const prefix = `[${timestamp}] [${step.toUpperCase()}]`;
            
            switch(level) {
                case 'error':
                    console.error(prefix, data);
                    break;
                case 'warn':
                    console.warn(prefix, data);
                    break;
                default:
                    console.log(prefix, data);
            }
            
            // Also show in UI for mobile debugging
            if (level === 'error') {
                showMessage(`DEBUG ERROR: ${step} - ${JSON.stringify(data)}`, 'error');
            }
        }

        let apiKey = localStorage.getItem('windyApiKey') || '';
        if (apiKey) {
            document.getElementById('apiKey').value = apiKey;
            debugLog('init', `API key loaded from storage: ${apiKey.substring(0, 8)}...`);
        }

        // Load default route on startup or button click
        async function loadDefaultRoute() {
            if (!apiKey) {
                debugLog('default-route', 'No API key available');
                showMessage('Please enter and save your API key first', 'error');
                return;
            }

            try {
                debugLog('default-route', 'Loading default route...');
                showLoading('üó∫Ô∏è Loading sample route...', 'Western US Road Trip - 11 waypoints');
                
                const response = await fetch('default.gpx');
                if (!response.ok) {
                    debugLog('default-route', 'Default GPX file not found', 'warn');
                    hideLoading();
                    showMessage('‚ùå Default route file not found. Please upload your own GPX file.', 'error');
                    return;
                }
                
                const gpxText = await response.text();
                debugLog('default-route', `Default GPX loaded: ${gpxText.length} characters`);
                
                updateProgress('üó∫Ô∏è Processing sample route...', 'Analyzing waypoints...');
                const waypoints = parseGPX(gpxText);
                
                if (waypoints.length > 0) {
                    debugLog('default-route', `Default route parsed: ${waypoints.length} waypoints`);
                    await fetchWeatherForWaypoints(waypoints);
                } else {
                    debugLog('default-route', 'No waypoints found in default route', 'warn');
                    hideLoading();
                    showMessage('‚ùå No waypoints found in default route file.', 'error');
                }
                
            } catch (error) {
                debugLog('default-route', `Error loading default route: ${error.message}`, 'error');
                hideLoading();
                showMessage(`‚ùå Error loading sample route: ${error.message}`, 'error');
            }
        }

        // Auto-load default route if API key is available
        if (apiKey) {
            setTimeout(loadDefaultRoute, 1000); // Small delay to let UI settle
        }

        function saveApiKey() {
            const key = document.getElementById('apiKey').value.trim();
            if (key) {
                localStorage.setItem('windyApiKey', key);
                apiKey = key;
                showMessage('API key saved successfully!', 'success');
                
                // Auto-load default route if no weather data is currently displayed
                if (!currentWeatherData || currentWeatherData.length === 0) {
                    setTimeout(loadDefaultRoute, 1000);
                }
            } else {
                showMessage('Please enter a valid API key', 'error');
            }
        }

        async function testApiKey() {
            if (!apiKey) {
                showMessage('Please enter and save your API key first', 'error');
                return;
            }

            showMessage('Testing API key... check browser console for details', 'success');
            
            try {
                // Test with San Francisco coordinates
                const testWeather = await fetchWeatherData(37.7749, -122.4194);
                showMessage(`API test successful! SF temp: ${testWeather.temperature}¬∞C`, 'success');
            } catch (error) {
                showMessage(`API test failed: ${error.message}`, 'error');
                console.error('API test error:', error);
            }
        }

        function showMessage(message, type) {
            const existing = document.querySelector('.error, .success');
            if (existing) existing.remove();

            const div = document.createElement('div');
            div.className = type;
            div.textContent = message;
            document.querySelector('.card').appendChild(div);

            setTimeout(() => div.remove(), 5000);
        }

        // File upload handling
        const fileInput = document.getElementById('fileInput');
        const uploadSection = document.querySelector('.upload-section');
        const loadingDiv = document.querySelector('.loading');
        const waypointsDiv = document.querySelector('.waypoints');

        // File input handling
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                debugLog('file-select', `File selected: ${e.target.files[0].name}`);
                handleFile(e.target.files[0]);
            }
        });

        async function handleFile(file) {
            debugLog('file-upload', `Processing file: ${file.name}, size: ${file.size} bytes`);
            
            // Immediate feedback
            showLoading('üìÅ File selected, validating...', `Processing: ${file.name}`);
            
            if (!apiKey) {
                debugLog('api-check', 'No API key found', 'error');
                hideLoading();
                showMessage('Please enter your Windy API key first', 'error');
                return;
            }

            if (!file.name.toLowerCase().endsWith('.gpx') && !file.name.toLowerCase().endsWith('.gpxd')) {
                debugLog('file-validation', `Invalid file type: ${file.name}`, 'error');
                hideLoading();
                showMessage('Please upload a GPX or GPXD file', 'error');
                return;
            }

            try {
                updateProgress('üìñ Reading file contents...', 'Please wait...');
                await new Promise(resolve => setTimeout(resolve, 100)); // Small delay to show loading

                debugLog('file-read', 'Reading file content...');
                const text = await file.text();
                debugLog('file-content', `File content length: ${text.length} characters`);
                debugLog('file-preview', `First 200 chars: ${text.substring(0, 200)}`);
                
                updateProgress('üó∫Ô∏è Parsing waypoints...', 'Analyzing route structure...');
                await new Promise(resolve => setTimeout(resolve, 200)); // Allow UI to update
                
                debugLog('parsing-start', 'Starting GPX/GPXD parsing...');
                const waypoints = parseGPX(text);
                debugLog('parsing-complete', `Parsed ${waypoints.length} waypoints`);
                
                if (waypoints.length === 0) {
                    debugLog('parsing-error', 'No waypoints found in file', 'error');
                    hideLoading();
                    showMessage('No waypoints found in GPX file. Please check your file format.', 'error');
                    return;
                }

                updateProgress('üå§Ô∏è Fetching weather forecasts...', `Found ${waypoints.length} waypoints`);
                await new Promise(resolve => setTimeout(resolve, 200)); // Allow UI to update

                debugLog('weather-fetch-start', `Starting weather fetch for ${waypoints.length} waypoints`);
                await fetchWeatherForWaypoints(waypoints);
                
            } catch (error) {
                debugLog('file-error', error, 'error');
                console.error('Error processing file:', error);
                hideLoading();
                showMessage('Error processing file: ' + error.message, 'error');
            }
        }

        function parseGPX(gpxText) {
            debugLog('parse-start', 'Starting XML parsing...');
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(gpxText, 'text/xml');
            
            const waypoints = [];
            const isGPXD = xmlDoc.documentElement.tagName === 'gpxd';
            
            debugLog('parse-type', `Document type: ${xmlDoc.documentElement.tagName}, isGPXD: ${isGPXD}`);
            
            if (isGPXD) {
                debugLog('gpxd-parse', 'Parsing GPXD format...');
                const waypointElements = xmlDoc.getElementsByTagName('waypoint');
                debugLog('gpxd-waypoints', `Found ${waypointElements.length} GPXD waypoint elements`);
                
                for (let wp of waypointElements) {
                    const lat = parseFloat(wp.getAttribute('lat'));
                    const lon = parseFloat(wp.getAttribute('lon'));
                    const nameElement = wp.getElementsByTagName('n')[0];
                    const name = nameElement ? nameElement.textContent : `Waypoint ${waypoints.length + 1}`;
                    
                    debugLog('gpxd-waypoint', `Processing: ${name} at ${lat}, ${lon}`);
                    
                    const arrivalElement = wp.getElementsByTagName('arrival')[0];
                    const departureElement = wp.getElementsByTagName('departure')[0];
                    
                    let dates = [];
                    if (arrivalElement && departureElement) {
                        const arrival = new Date(arrivalElement.textContent);
                        const departure = new Date(departureElement.textContent);
                        debugLog('gpxd-dates', `Arrival: ${arrival}, Departure: ${departure}`);
                        
                        // Generate dates for each day of stay
                        const currentDate = new Date(arrival);
                        while (currentDate <= departure) {
                            dates.push(new Date(currentDate));
                            currentDate.setDate(currentDate.getDate() + 1);
                        }
                    } else if (arrivalElement) {
                        const arrival = new Date(arrivalElement.textContent);
                        dates.push(arrival);
                        debugLog('gpxd-single-date', `Single date: ${arrival}`);
                    }
                    
                    debugLog('gpxd-final-dates', `Final dates for ${name}:`, dates);
                    waypoints.push({ lat, lon, name, type: 'gpxd', dates });
                }
            } else {
                debugLog('gpx-parse', 'Parsing standard GPX format...');
                
                // Parse waypoints
                const wptElements = xmlDoc.getElementsByTagName('wpt');
                debugLog('gpx-wpt', `Found ${wptElements.length} wpt elements`);
                
                for (let wpt of wptElements) {
                    const lat = parseFloat(wpt.getAttribute('lat'));
                    const lon = parseFloat(wpt.getAttribute('lon'));
                    const nameElement = wpt.getElementsByTagName('name')[0];
                    const name = nameElement ? nameElement.textContent : `Waypoint ${waypoints.length + 1}`;
                    
                    const today = new Date();
                    debugLog('gpx-waypoint', `GPX waypoint: ${name} at ${lat}, ${lon}, defaulting to ${today}`);
                    waypoints.push({ lat, lon, name, type: 'waypoint', dates: [today] });
                }
                
                // Parse route points (rtept) - This is what Windy exports!
                const rteptElements = xmlDoc.getElementsByTagName('rtept');
                debugLog('gpx-rtept', `Found ${rteptElements.length} rtept elements`);
                
                for (let i = 0; i < rteptElements.length; i++) {
                    const rtept = rteptElements[i];
                    const lat = parseFloat(rtept.getAttribute('lat'));
                    const lon = parseFloat(rtept.getAttribute('lon'));
                    const nameElement = rtept.getElementsByTagName('name')[0];
                    const name = nameElement ? `Route Point ${nameElement.textContent}` : `Route Point ${waypoints.length + 1}`;
                    
                    // Default to today + index days for route points
                    const futureDate = new Date();
                    futureDate.setDate(futureDate.getDate() + i);
                    debugLog('gpx-route-point', `Route point ${i}: ${name} at ${lat}, ${lon}, date: ${futureDate}`);
                    waypoints.push({ lat, lon, name, type: 'route', dates: [futureDate] });
                }
                
                // Parse track points (route) - fallback for other GPX formats
                const trkpts = xmlDoc.getElementsByTagName('trkpt');
                debugLog('gpx-trkpt', `Found ${trkpts.length} trkpt elements`);
                
                if (trkpts.length > 0 && waypoints.length === 0) {
                    debugLog('gpx-fallback', 'Using track points as fallback...');
                    for (let i = 0; i < trkpts.length; i += Math.max(1, Math.floor(trkpts.length / 10))) {
                        const trkpt = trkpts[i];
                        const lat = parseFloat(trkpt.getAttribute('lat'));
                        const lon = parseFloat(trkpt.getAttribute('lon'));
                        
                        const futureDate = new Date();
                        futureDate.setDate(futureDate.getDate() + Math.floor(i / Math.max(1, Math.floor(trkpts.length / 10))));
                        
                        const trackName = `Track Point ${Math.floor(i / Math.max(1, Math.floor(trkpts.length / 10))) + 1}`;
                        debugLog('gpx-track-point', `Track point: ${trackName} at ${lat}, ${lon}, date: ${futureDate}`);
                        
                        waypoints.push({ 
                            lat, 
                            lon, 
                            name: trackName,
                            type: 'track',
                            dates: [futureDate]
                        });
                    }
                }
            }
            
            debugLog('parse-complete', `Final waypoints count: ${waypoints.length}`);
            waypoints.forEach((wp, index) => {
                debugLog(`waypoint-${index}`, `${wp.name}: ${wp.lat}, ${wp.lon}, dates: ${wp.dates?.length || 0} items`, wp.dates?.length === 0 ? 'warn' : 'info');
                if (wp.dates && wp.dates.length > 0) {
                    wp.dates.forEach((date, dateIndex) => {
                        debugLog(`waypoint-${index}-date-${dateIndex}`, `Date ${dateIndex}: ${date} (type: ${typeof date}, isDate: ${date instanceof Date}, valid: ${!isNaN(date?.getTime())})`, !date || isNaN(date?.getTime()) ? 'error' : 'info');
                    });
                }
            });
            
            return waypoints;
        }

        async function fetchWeatherForWaypoints(waypoints) {
            const weatherData = [];
            
            for (let i = 0; i < waypoints.length; i++) {
                const waypoint = waypoints[i];
                try {
                    const weather = await fetchWeatherData(waypoint.lat, waypoint.lon);
                    weatherData.push({
                        ...waypoint,
                        weather
                    });
                } catch (error) {
                    console.error(`Error fetching weather for ${waypoint.name}:`, error);
                    weatherData.push({
                        ...waypoint,
                        weather: { error: 'Failed to fetch weather data' }
                    });
                }
                
                // Small delay to avoid rate limiting
                await new Promise(resolve => setTimeout(resolve, 200));
            }
            
            displayWeatherData(weatherData);
            loadingDiv.style.display = 'none';
            waypointsDiv.style.display = 'block';
        }

        async function fetchWeatherData(lat, lon, targetDate) {
            debugLog('weather-api-start', `Fetching weather for: ${lat}, ${lon}, target date: ${targetDate}`);
            
            // Validate parameters
            if (!lat || !lon) {
                throw new Error('Invalid coordinates provided');
            }
            
            // Validate and fix target date
            let safeTargetDate;
            if (!targetDate) {
                debugLog('weather-api-date', 'No target date provided, using tomorrow', 'warn');
                safeTargetDate = new Date();
                safeTargetDate.setDate(safeTargetDate.getDate() + 1);
            } else if (!(targetDate instanceof Date)) {
                debugLog('weather-api-date', 'Converting target date to Date object');
                safeTargetDate = new Date(targetDate);
            } else {
                safeTargetDate = targetDate;
            }
            
            // Validate date is valid
            if (isNaN(safeTargetDate.getTime())) {
                debugLog('weather-api-date', 'Invalid target date, using tomorrow', 'warn');
                safeTargetDate = new Date();
                safeTargetDate.setDate(safeTargetDate.getDate() + 1);
            }
            
            debugLog('weather-api-validated', `Using validated date: ${safeTargetDate}`);
            console.log('Using API key:', apiKey ? `${apiKey.substring(0, 8)}...` : 'NOT SET');
            
            const requestBody = {
                lat: lat,
                lon: lon,
                model: 'gfs',
                parameters: ['wind', 'temp', 'precip', 'rh', 'pressure'],
                levels: ['surface'],
                key: apiKey
            };
            
            console.log('Request body:', JSON.stringify(requestBody, null, 2));
            
            try {
                const response = await fetch('https://api.windy.com/api/point-forecast/v2', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody)
                });

                console.log('Response status:', response.status);

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('API error response:', errorText);
                    throw new Error(`Weather API error: ${response.status} - ${errorText}`);
                }

                const data = await response.json();
                console.log('API response data keys:', Object.keys(data));
                
                // Check if we got valid data
                if (!data.ts || data.ts.length === 0) {
                    throw new Error('No timestamp data received from API');
                }
                
                // Find the closest timestamp to our target date
                const targetTimestamp = safeTargetDate.getTime();
                let closestIndex = 0;
                let closestDiff = Math.abs(data.ts[0] - targetTimestamp);
                
                for (let i = 1; i < data.ts.length; i++) {
                    const diff = Math.abs(data.ts[i] - targetTimestamp);
                    if (diff < closestDiff) {
                        closestDiff = diff;
                        closestIndex = i;
                    }
                }
                
                console.log(`Target date: ${safeTargetDate.toISOString()}`);
                console.log(`Closest forecast: ${new Date(data.ts[closestIndex]).toISOString()}`);
                console.log(`Time difference: ${Math.round(closestDiff / (1000 * 60 * 60))} hours`);
                
                // Process the data for the closest timestamp
                const temp = data['temp-surface'] ? Math.round(data['temp-surface'][closestIndex] - 273.15) : 'N/A';
                const windSpeed = data['wind-surface'] ? Math.round(data['wind-surface'][closestIndex] * 3.6) : 'N/A';
                const pressure = data['pressure-surface'] ? Math.round(data['pressure-surface'][closestIndex] / 100) : 'N/A';
                const humidity = data['rh-surface'] ? Math.round(data['rh-surface'][closestIndex]) : 'N/A';
                const precip = data['precip-surface'] ? data['precip-surface'][closestIndex].toFixed(1) : 'N/A';

                const result = {
                    temperature: temp,
                    windSpeed: windSpeed,
                    pressure: pressure,
                    humidity: humidity,
                    precipitation: precip,
                    forecastDate: new Date(data.ts[closestIndex]),
                    requestedDate: safeTargetDate,
                    hoursOffset: Math.round(closestDiff / (1000 * 60 * 60))
                };
                
                console.log('Processed weather data:', result);
                return result;
                
            } catch (error) {
                console.error('Fetch error:', error);
                throw error;
            }
        }

        function displayWeatherData(weatherData) {
            waypointsDiv.innerHTML = '';
            
            // Add export button at the top
            const exportDiv = document.createElement('div');
            exportDiv.style.textAlign = 'center';
            exportDiv.style.marginBottom = '20px';
            exportDiv.innerHTML = `
                <button class="btn" onclick="exportToGPXD()" style="background: linear-gradient(45deg, #059669, #10b981);">
                    üì• Export as GPXD
                </button>
            `;
            waypointsDiv.appendChild(exportDiv);
            
            weatherData.forEach((point, index) => {
                const waypointDiv = document.createElement('div');
                waypointDiv.className = 'waypoint';
                
                const dateStr = point.date.toLocaleDateString('en-US', { 
                    weekday: 'long', 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric' 
                });
                
                const weatherContent = point.weather.error ? 
                    `<div class="error">${point.weather.error}</div>` :
                    `<div class="weather-grid">
                        <div class="weather-item">
                            <div class="weather-label">Temperature</div>
                            <div class="weather-value">${point.weather.temperature}¬∞C</div>
                        </div>
                        <div class="weather-item">
                            <div class="weather-label">Wind Speed</div>
                            <div class="weather-value">${point.weather.windSpeed} km/h</div>
                        </div>
                        <div class="weather-item">
                            <div class="weather-label">Pressure</div>
                            <div class="weather-value">${point.weather.pressure} hPa</div>
                        </div>
                        <div class="weather-item">
                            <div class="weather-label">Humidity</div>
                            <div class="weather-value">${point.weather.humidity}%</div>
                        </div>
                        <div class="weather-item">
                            <div class="weather-label">Precipitation</div>
                            <div class="weather-value">${point.weather.precipitation} mm</div>
                        </div>
                        <div class="weather-item">
                            <div class="weather-label">Forecast Time</div>
                            <div class="weather-value" style="font-size: 0.8rem;">${point.weather.forecastDate ? point.weather.forecastDate.toLocaleString() : 'N/A'}</div>
                        </div>
                    </div>`;
                
                const dateInputId = `date-${index}`;
                const dateValue = point.date.toISOString().split('T')[0];
                
                waypointDiv.innerHTML = `
                    <div class="waypoint-header">
                        <div>
                            <div class="waypoint-name">${point.name}</div>
                            <div class="coordinates">${point.lat.toFixed(4)}, ${point.lon.toFixed(4)}</div>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-size: 0.9rem; color: #6b7280; margin-bottom: 5px;">Visit Date:</div>
                            <input type="date" id="${dateInputId}" value="${dateValue}" 
                                   style="padding: 5px; border: 1px solid #d1d5db; border-radius: 5px;" 
                                   onchange="updateWaypointDate(${index}, this.value)" />
                        </div>
                    </div>
                    <div style="font-size: 1.1rem; font-weight: 600; color: #2563eb; margin-bottom: 15px;">
                        Weather forecast for ${dateStr}
                        ${point.weather.hoursOffset ? `<span style="font-size: 0.8rem; color: #6b7280;"> (¬±${point.weather.hoursOffset}h)</span>` : ''}
                    </div>
                    ${weatherContent}
                `;
                
                waypointsDiv.appendChild(waypointDiv);
            });
        }

        // Store the current weather data globally for date updates
        let currentWeatherData = [];

        // Load default route only when user clicks button
        async function loadDefaultRoute() {
            if (!apiKey) {
                debugLog('default-route', 'No API key available');
                showMessage('Please enter and save your API key first', 'error');
                return;
            }

            try {
                debugLog('default-route', 'Loading default route...');
                showLoading('üó∫Ô∏è Loading sample route...', 'Western US Road Trip - 11 waypoints');
                
                const response = await fetch('default.gpx');
                if (!response.ok) {
                    debugLog('default-route', 'Default GPX file not found', 'warn');
                    hideLoading();
                    showMessage('‚ùå Default route file not found. Please upload your own GPX file.', 'error');
                    return;
                }
                
                const gpxText = await response.text();
                debugLog('default-route', `Default GPX loaded: ${gpxText.length} characters`);
                
                updateProgress('üó∫Ô∏è Processing sample route...', 'Analyzing waypoints...');
                const waypoints = parseGPX(gpxText);
                
                if (waypoints.length > 0) {
                    debugLog('default-route', `Default route parsed: ${waypoints.length} waypoints`);
                    await fetchWeatherForWaypoints(waypoints);
                } else {
                    debugLog('default-route', 'No waypoints found in default route', 'warn');
                    hideLoading();
                    showMessage('‚ùå No waypoints found in default route file.', 'error');
                }
                
            } catch (error) {
                debugLog('default-route', `Error loading default route: ${error.message}`, 'error');
                hideLoading();
                showMessage(`‚ùå Error loading sample route: ${error.message}`, 'error');
            }
        }

        async function updateWaypointDate(index, newDateStr) {
            if (!currentWeatherData[index]) return;
            
            const newDate = new Date(newDateStr);
            const point = currentWeatherData[index];
            
            debugLog('date-update', `Updating ${point.name} from ${point.date.toDateString()} to ${newDate.toDateString()}`);
            
            // Update the date
            point.date = newDate;
            
            // Show loading for this specific waypoint
            const waypointDiv = document.querySelectorAll('.waypoint')[index + 1]; // +1 for export button
            const weatherGrid = waypointDiv.querySelector('.weather-grid');
            if (weatherGrid) {
                weatherGrid.innerHTML = `
                    <div style="text-align: center; padding: 20px; color: #2563eb;">
                        <div class="spinner" style="width: 20px; height: 20px; margin: 0 auto 10px;"></div>
                        <div>Updating forecast for ${newDate.toDateString()}...</div>
                    </div>`;
            }
            
            try {
                // Fetch new weather data
                debugLog('date-update-fetch', `Fetching new weather for ${point.name} on ${newDate.toDateString()}`);
                const weather = await fetchWeatherData(point.lat, point.lon, newDate);
                point.weather = weather;
                
                // Update the display
                displayWeatherData(currentWeatherData);
                
                showMessage(`‚úÖ Updated forecast for ${point.name} on ${newDate.toDateString()}`, 'success');
                
            } catch (error) {
                console.error('Error updating weather:', error);
                point.weather = { error: 'Failed to fetch updated weather data' };
                displayWeatherData(currentWeatherData);
                showMessage(`‚ùå Failed to update forecast for ${point.name}`, 'error');
            }
        }

        function exportToGPXD() {
            if (!currentWeatherData || currentWeatherData.length === 0) {
                showMessage('No waypoint data to export', 'error');
                return;
            }
            
            // Generate GPXD content
            const gpxdContent = generateGPXD(currentWeatherData);
            
            // Create and download file
            const blob = new Blob([gpxdContent], { type: 'application/xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `trip-${new Date().toISOString().split('T')[0]}.gpxd`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showMessage('GPXD file exported successfully!', 'success');
        }

        function generateGPXD(weatherData) {
            const now = new Date().toISOString();
            
            let waypoints = '';
            weatherData.forEach((point, index) => {
                const arrival = point.date.toISOString();
                const departure = new Date(point.date.getTime() + 24 * 60 * 60 * 1000).toISOString(); // +1 day
                
                waypoints += `
    <waypoint lat="${point.lat}" lon="${point.lon}">
      <n>${point.name}</n>
      <desc>Weather: ${point.weather.temperature}¬∞C, Wind: ${point.weather.windSpeed} km/h</desc>
      <arrival>${arrival}</arrival>
      <departure>${departure}</departure>
      <stay>PT24H</stay>
      <type>destination</type>
    </waypoint>`;
            });
            
            return `<?xml version="1.0" encoding="utf-8"?>
<gpxd creator="TripWeather" version="1.0" 
      xmlns="http://flylasse.github.io/gpxd/1.0" 
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  
  <metadata>
    <n>Trip Weather Plan</n>
    <desc>Weather-planned trip with forecasts</desc>
    <author>
      <n>Trip Weather App</n>
    </author>
    <time>${now}</time>
  </metadata>
  
  <trip>
    <n>My Trip</n>
    <type>mixed</type>
    <travelers>1</travelers>
    ${waypoints}
    
    <weather>
      <preferences>
        <preferred_temp_range min="15" max="30" unit="celsius"/>
      </preferences>
      <critical_parameters>
        <parameter>precipitation</parameter>
        <parameter>wind_speed</parameter>
        <parameter>temperature</parameter>
      </critical_parameters>
    </weather>
  </trip>
</gpxd>`;
        }

        // PWA Service Worker Registration
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js')
                    .then((registration) => {
                        console.log('SW registered: ', registration);
                    })
                    .catch((registrationError) => {
                        console.log('SW registration failed: ', registrationError);
                    });
            });
        }
    </script>
</body>
</html>